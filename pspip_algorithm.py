# -*- coding: utf-8 -*-

"""
/***************************************************************************
 PutSpacedPointsInPolygons
                                 A QGIS plugin
 Attempts to find the highest possible number of points in polygons if a
 certain distance between the points is given. Outputs a multipoint layer.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-08-09
        copyright            : (C) 2024 by Christian Lesem
        email                : christian@lesem.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Christian Lesem'
__date__ = '2024-08-09'
__copyright__ = '(C) 2024 by Christian Lesem'

# This will get replaced with a git SHA1 when you do a git archive
__revision__ = '$Format:%H$'

from qgis import processing

from qgis.PyQt.QtCore import (QCoreApplication,
                              QVariant)

from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterDistance,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterEnum,
                       QgsField,
                       QgsCoordinateReferenceSystem,
                       QgsReferencedRectangle,
                       QgsFeature,
                       QgsFields,
                       QgsWkbTypes,
                       QgsVectorLayer,
                       QgsGeometry)

from math import sqrt

class PutSpacedPointsInPolygonsAlgorithm(QgsProcessingAlgorithm):
    """
    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    DISTANCE = 'DISTANCE'
    ITER_X = 'ITER_X'
    ITER_Y = 'ITER_Y'
    ITER_ROT = 'ITER_ROT'
    GRID_SELECTION = 'GRID_SELECTION'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # Add the input vector features source (limited to polygon layers).
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input layer'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )

        # Add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Fitted_point_grids')
            )
        )

        # Add distance parameter.
        self.addParameter(
            QgsProcessingParameterDistance(
                self.DISTANCE,
                self.tr('Distance between points'),
                500,
                self.INPUT
                )
        )

        # Add parameter for choosing the number of iterations in x-direction.
        self.addParameter(
            QgsProcessingParameterNumber(
                self.ITER_X,
                description=self.tr('Number of iterations (x-direction)'),
                defaultValue=5,
                type=QgsProcessingParameterNumber.Integer,
                minValue=1,
                maxValue=100
            )
        )

        # Add parameter for choosing the number of iterations in y-direction.
        self.addParameter(
            QgsProcessingParameterNumber(
                self.ITER_Y,
                description=self.tr('Number of iterations (y-direction)'),
                defaultValue=5,
                type=QgsProcessingParameterNumber.Integer,
                minValue=1,
                maxValue=100
            )
        )

        # Add parameter for choosing the number of iterations for rotation.
        self.addParameter(
            QgsProcessingParameterNumber(
                self.ITER_ROT,
                description=self.tr('Number of iterations (rotation)'),
                defaultValue=5,
                type=QgsProcessingParameterNumber.Integer,
                minValue=1,
                maxValue=100
            )
        )

        # Add parameter for choosing the grid type(s) to be used.
        self.addParameter(
            QgsProcessingParameterEnum(
                self.GRID_SELECTION,
                self.tr('Grid types to use'),
                options=[self.tr('only triangle based grids'),
                         self.tr('only square based grids'),
                         self.tr('both triangle and square based grids')],
                defaultValue=0,
                optional=False)
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source.
        source = self.parameterAsSource(parameters, self.INPUT, context)
        print(type(source))

        # Retrieve additional parameters.
        SPACING = self.parameterAsInt(parameters, self.DISTANCE, context)
        ROT_ITERATIONS = self.parameterAsInt(parameters, self.ITER_X, context)
        X_ITERATIONS = self.parameterAsInt(parameters, self.ITER_Y, context)
        Y_ITERATIONS = self.parameterAsInt(parameters, self.ITER_ROT, context)
        GRID_TYPE = self.parameterAsInt(parameters, self.GRID_SELECTION, context)
        
        # Prepare fields that are to be added to the sink (the output layer).
        sink_fields = QgsFields()
        sink_fields.append(QgsField('fid', QVariant.Int))
        sink_fields.append(QgsField('NUMPOINTS', QVariant.Int))

        # Retrieve the sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, sink_fields, QgsWkbTypes.MultiPoint, source.sourceCrs())
        
        # Compute the number of steps to display within the progress bar.
        total = 100.0 / (source.featureCount() * X_ITERATIONS * Y_ITERATIONS * ROT_ITERATIONS) if source.featureCount() else 0
        # Get source EPSG code.       
        crs_epsg = int(source.sourceCrs().authid().split(":")[1])
        # Create CRS object. (This is going to be needed when creating
        # a QgsReferencedRectangle object example.)
        crs_obj = QgsCoordinateReferenceSystem(crs_epsg, QgsCoordinateReferenceSystem.EpsgCrsId)

        #### THE CENTRAL PART OF THE ALGORITHM
        # Iterate over each feature of the input polygon layer, performing the following steps:
        # + Create a temporary polygon layer and add only one element (containing the feature's geometry).
        #   (This is going to be needed later, when clipping the points.)
        # + Get the feature's bounding box.
        # + Create a grid of points within the above bounding box (-> output: point layer).
        # + Clip the point layer using the temporary polygon layer.
        # + Count the points within the feature polygon, retrieve the count ("NUMPOINTS") from the resulting layer.
        # + Use the "Collect geometries" tool ("native:collect") to transform the remaining point freatures
        #   from the points layer into a single MultiPoint feature, retrieve the resulting geometry
        # + Write the feature's fid, geometry (the above MultiPoint geometry) and the point count ("NUMPOINTS")
        #   into the feature sink.

        iter_count = 0 # needed for the progress bar

        for feature in source.getFeatures():

            # Stop the algorithm if cancel button has been clicked.
            if feedback.isCanceled():
                break  

            # Create new layer containing only the current feature (only geometry).
            # This will be needed later as input for the "native:clip" and 
            # "native:countpointsinpolygon" processing tools, which only accept fully
            # fledged layers als "OVERLAY" and "POLYGONS" paramters respectively.
            #
            # Simply selecting the current feature from the input layer using a construct
            # akin to input_lyr.selectByExpression(f'"fid"=\'{f_id}\'') does not work 
            # because the input_lyr in this case is not a vanilla QgsVectorLayer object
            # but a QgsProcessingFeatureSource object, which does not provide a selection
            # method.
            lyr_with_current_feature_only = QgsVectorLayer(f'Polygon?crs={crs_epsg}', f'{source.sourceName()}_temp1', 'memory')
            feature_obj_1 = QgsFeature()
            feature_obj_1.setGeometry(feature.geometry())
            pr = lyr_with_current_feature_only.dataProvider()
            pr.addFeatures([feature_obj_1])

            # Get the feature's bounding box (-> QgsRectangle object)
            f_bb = feature.geometry().boundingBox()

            # Make the bounding box square-shaped by extending the narrow sides
            bb_width = f_bb.width()
            bb_height = f_bb.height()

            if (bb_width > bb_height):
                diff_side = (bb_width - bb_height) / 2
                f_bb.setYMinimum(f_bb.yMinimum() - diff_side)
                f_bb.setYMaximum(f_bb.yMaximum() + diff_side)
            elif (bb_width < bb_height):
                diff_side = (bb_height - bb_width) / 2
                f_bb.setXMinimum(f_bb.xMinimum() - diff_side)
                f_bb.setXMaximum(f_bb.xMaximum() + diff_side)

            # Add an additional padding of length "SPACING" in each direction 
            account_for_virtual_circle = (f_bb.width() * sqrt(2) - f_bb.width())  / 2
            
            f_bb.set(f_bb.xMinimum() - account_for_virtual_circle - SPACING,
                     f_bb.yMinimum() - account_for_virtual_circle - SPACING,
                     f_bb.xMaximum() + account_for_virtual_circle + SPACING,
                     f_bb.yMaximum() + account_for_virtual_circle + SPACING)

            bb_centroid = f_bb.center()

            bb_for_grid_creation = QgsReferencedRectangle(f_bb, crs_obj)

            grids = []
            
            if GRID_TYPE == 0 or GRID_TYPE == 2:
                polygon_lyr_triang = processing.run(
                    "native:creategrid", {
                        'TYPE':4, # Type 4 stands for hexagons (polygons)
                        'EXTENT':bb_for_grid_creation,
                        'HSPACING':SPACING,
                        'VSPACING':SPACING,
                        'HOVERLAY':1,
                        'VOVERLAY':1,
                        'CRS':QgsCoordinateReferenceSystem(crs_obj),
                        'OUTPUT':'TEMPORARY_OUTPUT'})["OUTPUT"]
                
                # By retrieving each hexagon's centroid, a triangle based grid is created.
                points_lyr_triang = processing.run(
                    "native:centroids", {
                        'INPUT':polygon_lyr_triang,
                        'ALL_PARTS':True,
                        'OUTPUT':'TEMPORARY_OUTPUT'})["OUTPUT"]
                range1 = range(0, 120, int(120 / ROT_ITERATIONS))
                grids.append({"layer": points_lyr_triang, "range": range1})

            if GRID_TYPE == 1 or GRID_TYPE == 2:
                points_lyr_square = processing.run(
                    "native:creategrid", {
                        'TYPE':0, # Type 0 stands for points (arranged in square based grid)
                        'EXTENT':bb_for_grid_creation,
                        'HSPACING':SPACING,
                        'VSPACING':SPACING,
                        'HOVERLAY':1,
                        'VOVERLAY':1,
                        'CRS':QgsCoordinateReferenceSystem(crs_obj),
                        'OUTPUT':'TEMPORARY_OUTPUT'})["OUTPUT"]
                range2 = range(0, 90, int(90 / ROT_ITERATIONS))
                grids.append({"layer": points_lyr_square, "range": range2})
            
            best_arrangement = {"layer": None, "NUMPOINTS": 0}

            for grid in grids:

                # Stop the algorithm if cancel button has been clicked.
                if feedback.isCanceled():
                    break

                for degrees in grid["range"]:

                    # Stop the algorithm if cancel button has been clicked.
                    if feedback.isCanceled():
                        break

                    points_lyr_rotated = processing.run(
                        "native:rotatefeatures", {
                            'INPUT':grid["layer"],
                            'ANGLE':degrees,
                            'ANCHOR': f"{bb_centroid.x()}, {bb_centroid.y()} [EPSG:{crs_epsg}]",
                            # 'ANCHOR':bb_centroid,
                            'OUTPUT':'TEMPORARY_OUTPUT'
                                })["OUTPUT"]
                    
                    for x_translate_dist in range(0, SPACING, int(SPACING / X_ITERATIONS)):

                        # Stop the algorithm if cancel button has been clicked.
                        if feedback.isCanceled():
                            break

                        points_lyr_x_shifted = processing.run("native:translategeometry", {
                            'INPUT':points_lyr_rotated,
                            'DELTA_X':x_translate_dist,
                            'DELTA_Y':0,
                            'DELTA_Z':0,
                            'DELTA_M':0,
                            'OUTPUT':'TEMPORARY_OUTPUT'
                                })["OUTPUT"]
                        
                        for y_translate_dist in range(0, SPACING, int(SPACING / Y_ITERATIONS)):

                            # Stop the algorithm if cancel button has been clicked.
                            if feedback.isCanceled():
                                break

                            # Update the progress bar.
                            progress = int(iter_count * total)
                            feedback.setProgress(progress) 

                            iter_count += 1

                            points_lyr_y_shifted = processing.run("native:translategeometry", {
                            'INPUT':points_lyr_x_shifted,
                            'DELTA_X':0,
                            'DELTA_Y':y_translate_dist,
                            'DELTA_Z':0,
                            'DELTA_M':0,
                            'OUTPUT':'TEMPORARY_OUTPUT'
                                },)["OUTPUT"]
                            
                            # Clip the points lyr with the feature layer as the overlay.
                            points_clipped_lyr = processing.run(
                                    "native:clip", {
                                        'INPUT' : points_lyr_y_shifted,
                                        'OUTPUT' : 'TEMPORARY_OUTPUT',
                                        'OVERLAY' : lyr_with_current_feature_only
                                    })["OUTPUT"]
                            
                            # Count the points within the polygon.
                            counter_lyr = processing.run("native:countpointsinpolygon", {
                                        'POLYGONS': lyr_with_current_feature_only,
                                        'POINTS':points_clipped_lyr,
                                        'WEIGHT':'',
                                        'CLASSFIELD':'',
                                        'FIELD':'NUMPOINTS',
                                        'OUTPUT':'TEMPORARY_OUTPUT'})["OUTPUT"]

                            # Retrieve the number of points from the only feature in the counter layer.            
                            try:
                                numpoints = int(counter_lyr.getFeature(1)["NUMPOINTS"])

                                # Make MultiPoint from the single points.
                                multipart_points_lyr = processing.run(
                                    "native:collect", {
                                        'INPUT':points_clipped_lyr,
                                        'FIELD':[],
                                        'OUTPUT':'TEMPORARY_OUTPUT'
                                        })["OUTPUT"]
                                
                                if numpoints > best_arrangement['NUMPOINTS']:
                                #    layer_cloned = multipart_points_lyr.clone()
                                #    best_arrangement["layer"] = layer_cloned
                                    best_arrangement["layer"] = multipart_points_lyr
                                    best_arrangement["NUMPOINTS"] = numpoints

                            except (RuntimeError):
                                print("RuntimeError was thrown. Continue for loop.")
                                continue         
            
            # Create and fill the feature that is to be added to the sink.
            feature_obj_2 = QgsFeature()  
            if lyr := best_arrangement["layer"]:     
                geom = lyr.getFeature(1).geometry()
            else:
                geom = QgsGeometry() # create empty geometry
            
            feature_obj_2.setGeometry(geom)
            feature_obj_2.setAttributes([feature.id(), best_arrangement["NUMPOINTS"]])
        
            # Add feature to the sink.
            sink.addFeature(feature_obj_2, QgsFeatureSink.FastInsert)

        # Return the results of the algorithm. 
        return {self.OUTPUT: dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'putspacedpointsinpolygons'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr("Put spaced points in polygons")
    
    def shortHelpString(self):
        """
        Returns a localised short helper string for the algorithm. This string
        should provide a basic description about what the algorithm does and the
        parameters and outputs associated with it..
        """
        return self.tr('This algorithm takes a polygon layer and asks you to enter\
                       a "Distance between points" value. Taking the distance constraint \
                       into account, it attempts to find an arrangement of points within \
                       each polygon that yields the highest possible number of points \
                       (note the caveat in the following paragraph). The algorithm outputs \
                       a multipoint layer containing one feature for each feature from the \
                       input layer. Its attributes are an "FID" (int) field referring to \
                       the input feature\'s fid and a "NUMPOINTS" (int) field stating the \
                       number of points that were fitted. The multipoint geometry contains \
                       an arrangement of points that yielded the highest number of points.\
                       \n\nPlease bear in mind that this is an approximation algorithm that \
                       is based on testing a large number of possible point arrangements. \
                       This approach does not make it possible to find the very best \
                       solution with certainty.\n\nThe basis for the testing process are \
                       regular point grids. You can choose whether you would like the \
                       algorithm to use square based grids, triangle based grids or both. \
                       Please note that square based grids provide the optimum result only \
                       in special cases (relatively small, rectangular input polygons).\
                       \n\nThe algorithm takes the grids and varies them by moving them \
                       step by step in the x-direction and y-direction and rotating them \
                       (and all of them at the same time). You can specify how many \
                       iterations you want to be performed for each of these factors. Here \
                       is an example to help you understand this: If you have specified 500 \
                       metres as the distance and 10 as the number of iterations (x-direction), \
                       the grid is moved horizontally in steps of 50 metres. The range for \
                       rotation iterations is between 0 and 90 (excluded) degrees for square \
                       based grids and 0 to 120 (excluded) degrees for triangle based grids.\
                       \n\nHigher numbers of iterations do not necessarily lead to better \
                       results (it is even possible to get worse results). As a starting \
                       point, use the default values (5 iterations for each factor) and then \
                       experiment with different settings. Too many iterations can bring the \
                       computer to its limits and cause the plug-in (and QGIS itself) to \
                       crash. 10 iterations each should be feasible, beyond that it may get \
                       critical. If you run the plugin with a higher number of iterations, \
                       please leave QGIS alone to minimise the risk of crashes.')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PutSpacedPointsInPolygonsAlgorithm()
    
    # def flags(self):
    #     return super().flags() | QgsProcessingAlgorithm.FlagNoThreading
